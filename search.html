<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified Dev & AI Search</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa; /* Lighter gray background */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        /* --- Animations --- */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes searchBarMove {
             0% {
                 transform: translateY(calc(50vh - 50% - 7.5vh)); /* Approx center */
                 width: 90%; /* Start wider */
                 max-width: 600px;
             }
             100% {
                 transform: translateY(0);
                 width: 100%; /* Full width within wrapper */
                 max-width: 600px;
             }
        }
        @keyframes titleFadeOut {
             from { opacity: 1; transform: scale(1); }
             to { opacity: 0; transform: scale(0.9); }
        }

        /* --- Search Container & Form --- */
        #search-container {
            width: 100%;
            padding: 0 1rem; /* Add horizontal padding */
            transition: padding-top 0.5s ease-out, padding-bottom 0.5s ease-out;
            display: flex; /* Use flex for alignment */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        #search-container.initial-state {
            flex-grow: 1; /* Takes up available space */
            padding-top: 0;
            padding-bottom: 15vh; /* Push up slightly from true center */
        }
        #search-container.searched-state {
            padding-top: 1.5rem;
            padding-bottom: 1rem;
            align-items: flex-start; /* Align items to top */
        }

        #search-form-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px; /* Limit search bar width */
            /* Animation applied when moving to top */
        }
        #search-container.searched-state #search-form-wrapper {
             /* Animation applied via JS class toggle */
        }

        #search-form {
            width: 100%;
            display: flex;
            align-items: center;
            border: 1px solid #dfe1e5;
            border-radius: 9999px; /* Fully rounded */
            padding: 0.6rem 1.2rem; /* Slightly larger padding */
            background-color: #ffffff;
            box-shadow: 0 1px 6px rgba(32, 33, 36, 0.1);
            transition: box-shadow 0.3s ease, border-color 0.3s ease;
            margin-bottom: 0.75rem; /* Space below search bar for filters */
        }
         #search-form:hover,
         #search-form:focus-within {
             box-shadow: 0 2px 8px rgba(32, 33, 36, 0.15);
             border-color: #dadce0;
         }
         #search-input {
            flex-grow: 1;
            border: none;
            outline: none;
            padding: 0.5rem;
            font-size: 1rem;
            background: transparent;
         }
         #search-button {
            background: transparent;
            border: none;
            color: #4285f4; /* Google blue */
            cursor: pointer;
            padding: 0.5rem;
            margin-left: 0.5rem;
            transition: transform 0.2s ease;
         }
         #search-button:hover {
             transform: scale(1.1);
         }
         #search-button i {
             font-size: 1.25rem;
         }

         /* Title Animation */
         .initial-state-title {
             transition: opacity 0.4s ease-out, transform 0.4s ease-out;
             transform-origin: bottom;
         }
         .initial-state-title.fade-out {
             opacity: 0;
             transform: scale(0.9);
         }

         /* Filter Controls Animation */
         #filter-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            opacity: 0; /* Start hidden */
            transition: opacity 0.5s 0.3s ease-out; /* Fade in after delay */
         }
         #filter-controls.visible {
             opacity: 1;
         }
         .filter-button {
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 9999px;
            border: 1px solid #dfe1e5;
            background-color: #f8f9fa;
            color: #5f6368;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
         }
         .filter-button:hover {
            background-color: #f1f3f4;
            border-color: #dadce0;
            transform: translateY(-1px); /* Slight lift on hover */
         }
         .filter-button.active {
            background-color: #e8f0fe;
            border-color: #d2e3fc;
            color: #1967d2;
            font-weight: 500;
         }

        /* Results Area & List Animation */
        #results-area {
            padding: 1rem 1rem 2rem 1rem;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            opacity: 0; /* Start hidden */
            animation: fadeIn 0.6s 0.2s ease-out forwards; /* Fade in after search bar moves */
        }
        .results-list {
            list-style: none;
            padding: 0;
            margin: 0;
            background-color: #ffffff;
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        /* Individual Result Item Animation */
        .result-item {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e8eaed;
            transition: background-color 0.2s ease-in-out;
            position: relative;
            opacity: 0; /* Start hidden */
            animation: slideUp 0.5s ease-out forwards;
        }
        /* Stagger animation delay for list items */
        .result-item:nth-child(1) { animation-delay: 0.1s; }
        .result-item:nth-child(2) { animation-delay: 0.15s; }
        .result-item:nth-child(3) { animation-delay: 0.2s; }
        .result-item:nth-child(4) { animation-delay: 0.25s; }
        .result-item:nth-child(5) { animation-delay: 0.3s; }
        /* Add more if expecting more results per page */
        .result-item:nth-child(6) { animation-delay: 0.35s; }
        .result-item:nth-child(7) { animation-delay: 0.4s; }
        .result-item:nth-child(8) { animation-delay: 0.45s; }
        .result-item:nth-child(9) { animation-delay: 0.5s; }
        .result-item:nth-child(10) { animation-delay: 0.55s; }


        .result-item:last-child {
            border-bottom: none;
        }
        .result-item:hover {
            background-color: #f0f3f5; /* Slightly darker hover */
        }
         .result-item .platform-icon {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.25rem; /* text-xl */
            color: #adb5bd; /* gray-400 */
            transition: transform 0.3s ease;
         }
         .result-item:hover .platform-icon {
             transform: scale(1.1);
         }
        .result-item a {
            color: #1a0dab; /* Google link blue */
            text-decoration: none;
            font-size: 1.125rem; /* text-lg */
            display: block;
            margin-bottom: 0.25rem;
            padding-right: 2rem;
            transition: color 0.2s ease;
        }
        .result-item a:hover {
            text-decoration: underline;
            color: #120a7a; /* Darker blue on hover */
        }
        .result-item .description {
            color: #4d5156;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 2rem;
        }
        .result-item .meta {
            font-size: 0.875rem;
            color: #70757a;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem 1rem;
            padding-right: 2rem;
        }
         .result-item .meta span {
             display: inline-flex;
             align-items: center;
             gap: 0.25rem;
         }
         .result-item .meta i {
             color: #80868b;
             width: 1em;
             text-align: center;
         }
        .error-message {
            color: #d93025;
            background-color: #fce8e6;
            border: 1px solid #f9c6c2;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
            text-align: center;
            animation: fadeIn 0.5s ease-out;
        }
        #results-message {
             text-align: center;
             color: #70757a;
             padding: 1.5rem;
             font-size: 1rem;
             background-color: #ffffff;
             border-radius: 0.5rem;
             box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
             margin-top: 1rem;
             animation: fadeIn 0.5s ease-out;
        }
        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: #70757a;
            font-size: 1rem;
            text-align: center;
            position: fixed; /* Make loader fixed */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent background */
            border-radius: 0.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 10; /* Ensure it's above other content */
            opacity: 0; /* Start hidden */
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .loading-indicator.visible {
            opacity: 1;
            visibility: visible;
        }
        .spinner {
            border: 4px solid #f3f4f6;
            border-top: 4px solid #4285f4;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
            margin-right: 0.75rem; /* Space between spinner and text */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Hide elements */
        .hidden {
            display: none !important; /* Use important to override potential conflicts */
        }

    </style>
</head>
<body>

    <div id="search-container" class="initial-state w-full px-4">
        <div id="search-form-wrapper">
             <h1 class="text-4xl font-bold text-gray-700 mb-6 text-center initial-state-title">
                 <span class="text-blue-600">U</span><span class="text-red-600">n</span><span class="text-yellow-500">i</span><span class="text-blue-600">f</span><span class="text-green-600">i</span><span class="text-red-600">e</span>d Search
             </h1>
            <form id="search-form">
                <input type="text" id="search-input" name="query" required placeholder="Search GitHub, GitLab, Bitbucket, Hugging Face...">
                <button type="submit" id="search-button" title="Search">
                    <i class="fas fa-search"></i>
                </button>
            </form>
            <div id="filter-controls" class="hidden">
                <button class="filter-button active" data-sort="relevant">Relevant</button>
                <button class="filter-button" data-sort="updated">Updated</button>
                <button class="filter-button" data-sort="likes">Likes/Stars</button>
                <button class="filter-button" data-sort="downloads">Downloads</button>
            </div>
        </div>
    </div>

    <div id="loading" class="loading-indicator">
        <div class="spinner"></div>
        <span>Searching...</span>
    </div>

    <div id="error-message" class="error-message hidden max-w-xl mx-auto"></div>

    <div id="results-area" class="hidden">
         <ul id="combined-results-list" class="results-list">
             </ul>
         <div id="results-message" class="hidden"></div>
    </div>

    <script>
        // --- DOM Elements ---
        const searchContainer = document.getElementById('search-container');
        const searchFormWrapper = document.getElementById('search-form-wrapper');
        const searchForm = document.getElementById('search-form');
        const searchInput = document.getElementById('search-input');
        const loadingIndicator = document.getElementById('loading');
        const errorMessageDiv = document.getElementById('error-message');
        const resultsArea = document.getElementById('results-area');
        const initialStateTitle = document.querySelector('.initial-state-title');
        const combinedResultsList = document.getElementById('combined-results-list');
        const resultsMessage = document.getElementById('results-message');
        const filterControls = document.getElementById('filter-controls');
        const filterButtons = filterControls.querySelectorAll('.filter-button');

        // --- Constants ---
        const GITHUB_API_URL = 'https://api.github.com/search/repositories';
        const GITLAB_API_URL = 'https://gitlab.com/api/v4/projects';
        const BITBUCKET_API_URL = 'https://api.bitbucket.org/2.0/repositories';
        const HUGGINGFACE_API_URL = 'https://huggingface.co/api/models';
        const RESULTS_PER_PAGE = 10;

        // --- State ---
        let currentSort = 'relevant';
        let currentQuery = '';
        let isInitialState = true; // Track if it's the first search

        // --- Event Listeners ---
        searchForm.addEventListener('submit', (event) => {
             event.preventDefault();
             const query = searchInput.value.trim();
             if (query === currentQuery && !isInitialState) return; // Avoid re-searching same query unless filters change
             currentQuery = query;
             performSearch();
        });

        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                const newSort = button.getAttribute('data-sort');
                if (newSort !== currentSort) {
                    currentSort = newSort;
                    updateFilterButtonsUI();
                    if (currentQuery) {
                         performSearch();
                    }
                }
            });
        });


        // --- Functions ---

        /**
         * Main function to perform the search.
         */
        async function performSearch() {
             if (!currentQuery) {
                 showError("Please enter a search query.");
                 return;
             }

             clearResultsAndErrors();
             showLoading(true); // Show loader immediately

             // --- UI Transition ---
             if (isInitialState) {
                 // Animate title fade out
                 initialStateTitle?.classList.add('fade-out');
                 // Delay search container class change slightly to allow title fade
                 setTimeout(() => {
                    searchContainer.classList.remove('initial-state');
                    searchContainer.classList.add('searched-state');
                    filterControls.classList.add('visible'); // Make filters visible after move
                 }, 150); // Adjust timing as needed
                 isInitialState = false;
             } else {
                 // If not initial state, filters are already visible
                 filterControls.classList.add('visible');
             }
             resultsArea.classList.remove('hidden'); // Prepare results area

             // --- API URLs & Fetching (same as before) ---
             const encodedQuery = encodeURIComponent(currentQuery);
             let githubUrl = `${GITHUB_API_URL}?q=${encodedQuery}&per_page=${RESULTS_PER_PAGE}`;
             let gitlabUrl = `${GITLAB_API_URL}?search=${encodedQuery}&per_page=${RESULTS_PER_PAGE}`;
             let bitbucketUrl = `${BITBUCKET_API_URL}?q=${encodedQuery}&page=1&pagelen=${RESULTS_PER_PAGE}`;
             let huggingfaceUrl = `${HUGGINGFACE_API_URL}?search=${encodedQuery}&limit=${RESULTS_PER_PAGE}&full=true`;

             switch (currentSort) {
                 case 'updated':
                     githubUrl += '&sort=updated&order=desc';
                     gitlabUrl += '&sort=desc&order_by=last_activity_at';
                     bitbucketUrl += '&sort=-updated_on';
                     huggingfaceUrl += '&sort=lastModified&direction=-1';
                     break;
                 case 'likes':
                     githubUrl += '&sort=stars&order=desc';
                     huggingfaceUrl += '&sort=likes&direction=-1';
                     break;
                 case 'downloads':
                     huggingfaceUrl += '&sort=downloads&direction=-1';
                     break;
                 case 'relevant':
                 default: break;
             }

             let combinedResults = [];
             let fetchErrors = 0;

             try {
                 const responses = await Promise.allSettled([
                     fetch(githubUrl, { headers: { 'Accept': 'application/vnd.github.v3+json' } }),
                     fetch(gitlabUrl),
                     fetch(bitbucketUrl),
                     fetch(huggingfaceUrl)
                 ]);

                 // Process results
                 if (responses[0].status === 'fulfilled' && responses[0].value.ok) {
                     const data = await responses[0].value.json();
                     combinedResults.push(...transformGitHubResults(data.items || []));
                 } else { fetchErrors++; logFetchError(responses[0], 'GitHub'); }

                 if (responses[1].status === 'fulfilled' && responses[1].value.ok) {
                     const data = await responses[1].value.json();
                     combinedResults.push(...transformGitLabResults(data || []));
                 } else { fetchErrors++; logFetchError(responses[1], 'GitLab'); }

                 if (responses[2].status === 'fulfilled' && responses[2].value.ok) {
                     const data = await responses[2].value.json();
                     combinedResults.push(...transformBitbucketResults(data.values || []));
                 } else { fetchErrors++; logFetchError(responses[2], 'Bitbucket'); }

                 if (responses[3].status === 'fulfilled' && responses[3].value.ok) {
                     const data = await responses[3].value.json();
                     combinedResults.push(...transformHuggingFaceResults(data || []));
                 } else { fetchErrors++; logFetchError(responses[3], 'Hugging Face'); }

                 // Display results - animations handled by CSS
                 displayCombinedResults(combinedResults);

                 // Handle No Results / All Errors
                 if (combinedResults.length === 0) {
                     resultsArea.classList.remove('hidden'); // Ensure area is visible for message
                     if (fetchErrors === responses.length) {
                         showError("Failed to fetch results from any platform. Please check your connection or try again later.");
                     } else {
                         const sortTextMap = { relevant: 'relevance', updated: 'most updated', likes: 'most likes/stars', downloads: 'most downloads' };
                         showResultsMessage(`No results found for "${escapeHtml(currentQuery)}" sorted by ${sortTextMap[currentSort]}.`);
                     }
                 } else {
                     resultsArea.classList.remove('hidden'); // Ensure results area is visible
                 }

             } catch (error) {
                 console.error("General Search Error:", error);
                 showError("An unexpected error occurred during the search.");
                 resultsArea.classList.add('hidden'); // Hide results area on major error
             } finally {
                 showLoading(false); // Hide loader when done
             }
        }

        /** Logs fetch errors to the console. */
        function logFetchError(result, platformName) {
            const status = result.value?.status;
            const reason = result.reason?.message || `HTTP Error: ${status}`;
            console.error(`${platformName} Fetch Error: ${reason}`, result.reason || result.value);
        }

        // --- Data Transformation Functions (Unchanged) ---
        function transformGitHubResults(items) {
            return items.map(item => ({ platform: 'github', title: item.full_name, url: item.html_url, description: item.description || '', meta: [ { icon: 'fas fa-star', value: item.stargazers_count.toLocaleString(), label: 'Stars' }, item.language ? { icon: 'fas fa-code', value: item.language, label: 'Language' } : null, { icon: 'fas fa-user', value: item.owner.login, label: 'Owner' } ].filter(Boolean) }));
        }
        function transformGitLabResults(projects) {
            return projects.map(project => ({ platform: 'gitlab', title: project.name_with_namespace, url: project.web_url, description: project.description || '', meta: [ { icon: 'fas fa-star', value: project.star_count.toLocaleString(), label: 'Stars' }, { icon: 'fas fa-code-fork', value: project.forks_count.toLocaleString(), label: 'Forks' }, { icon: 'fas fa-user', value: project.namespace.name, label: 'Namespace' } ] }));
        }
        function transformBitbucketResults(repos) {
            return repos.map(repo => ({ platform: 'bitbucket', title: repo.full_name, url: repo.links?.html?.href || '#', description: repo.description || '', meta: [ repo.language ? { icon: 'fas fa-code', value: repo.language, label: 'Language' } : null, { icon: 'fas fa-user', value: repo.owner?.display_name || repo.workspace?.name || 'Unknown', label: 'Owner' }, repo.updated_on ? { icon: 'fas fa-clock', value: `Updated: ${new Date(repo.updated_on).toLocaleDateString()}`, label: 'Updated' } : null ].filter(Boolean) }));
        }
        function transformHuggingFaceResults(models) {
             if (!Array.isArray(models)) { console.warn("Hugging Face API did not return an array:", models); return []; }
            return models.map(model => ({ platform: 'huggingface', title: model.modelId, url: `https://huggingface.co/${model.modelId}`, description: model.cardData?.description || model.description || '', meta: [ { icon: 'fas fa-heart', value: model.likes?.toLocaleString() || 0, label: 'Likes' }, (typeof model.downloads !== 'undefined') ? { icon: 'fas fa-download', value: model.downloads.toLocaleString(), label: 'Downloads' } : null, model.pipeline_tag ? { icon: 'fas fa-tags', value: model.pipeline_tag, label: 'Task' } : null, { icon: 'fas fa-user', value: model.author || model.modelId.split('/')[0], label: 'Author' }, model.lastModified ? { icon: 'fas fa-clock', value: `Updated: ${new Date(model.lastModified).toLocaleDateString()}`, label: 'Updated' } : null ].filter(Boolean) }));
        }

        /** Displays the combined results in the list. */
        function displayCombinedResults(results) {
            // Clear previous results immediately before adding new ones
            combinedResultsList.innerHTML = '';

            if (!results || results.length === 0) {
                return; // Message handled by caller
            }

            // Ensure results area is visible before adding items
             resultsArea.classList.remove('hidden');

            results.forEach((result, index) => {
                const listItem = document.createElement('li');
                listItem.className = 'result-item';
                // Apply staggered delay directly via style attribute
                listItem.style.animationDelay = `${index * 0.05 + 0.1}s`; // Faster stagger

                let platformIconClass = '';
                switch (result.platform) {
                    case 'github': platformIconClass = 'fab fa-github'; break;
                    case 'gitlab': platformIconClass = 'fab fa-gitlab'; break;
                    case 'bitbucket': platformIconClass = 'fab fa-bitbucket'; break;
                    case 'huggingface': platformIconClass = 'fas fa-robot'; break;
                }

                const metaHtml = result.meta.map(m => `
                    <span title="${m.label || ''}"><i class="${m.icon}"></i> ${escapeHtml(m.value)}</span>
                `).join('');

                listItem.innerHTML = `
                    ${platformIconClass ? `<i class="platform-icon ${platformIconClass}" title="${result.platform}"></i>` : ''}
                    <a href="${result.url}" target="_blank" rel="noopener noreferrer">${escapeHtml(result.title)}</a>
                    <p class="description">${result.description ? escapeHtml(result.description) : 'No description available.'}</p>
                    <div class="meta">
                        ${metaHtml}
                    </div>
                `;
                combinedResultsList.appendChild(listItem);
            });
        }

        /** Shows or hides the main loading indicator. */
        function showLoading(isLoading) {
            // Use class toggle for visibility/opacity transition
            loadingIndicator.classList.toggle('visible', isLoading);
        }

        /** Displays the general error message. */
        function showError(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.classList.remove('hidden');
            // Hide results area when showing a general error
            resultsArea.classList.add('hidden');
        }

        /** Displays a message in the results area (e.g., "No results found"). */
        function showResultsMessage(message) {
            resultsMessage.textContent = message;
            resultsMessage.classList.remove('hidden');
            // Ensure results list is empty when showing this message
            combinedResultsList.innerHTML = '';
        }

        /** Clears previous search results and all error/status messages. */
        function clearResultsAndErrors() {
            errorMessageDiv.classList.add('hidden');
            errorMessageDiv.textContent = '';
            combinedResultsList.innerHTML = ''; // Clear list content
            resultsMessage.classList.add('hidden'); // Hide no-results message
            resultsMessage.textContent = '';
            // Don't hide resultsArea here, performSearch manages its visibility
            // Don't hide filterControls here either
        }

        /** Updates the visual state of filter buttons. */
        function updateFilterButtonsUI() {
            filterButtons.forEach(button => {
                button.classList.toggle('active', button.getAttribute('data-sort') === currentSort);
            });
        }

        /** Escapes HTML characters to prevent XSS. */
        function escapeHtml(str) {
            str = String(str || '');
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return str.replace(/[&<>"']/g, m => map[m]);
        }

        // Initial UI setup
        updateFilterButtonsUI();

    </script>

</body>
</html>
